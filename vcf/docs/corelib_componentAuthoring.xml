<!--
Copyright (c) 2000-2003, Jim Crafton
All rights reserved.
Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions
are met:
	Redistributions of source code must retain the above copyright
	notice, this list of conditions and the following disclaimer.

	Redistributions in binary form must reproduce the above copyright
	notice, this list of conditions and the following disclaimer in 
	the documentation and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS
OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

NB: This software will not save the world.
-->

<section><title>Component Authoring </title>
	<para>
	The VCF supports components as a way of re-using code, and a way to 
	manipulate this code from within a design time UI editor. The VCF
	Builder project aims to provide one type of an editor like this.
	The rest of this documet will explain how to write custom components 
	such that a tool like the <ulink url="http://vcfbuilder.org">VCF Builder</ulink> 
	can re-use them and make them available to other developers.
	</para>
	<para>
	Components are edited at design time by editing their properties. 
	Components also have event's, to which event handler's can be added to. 
	In addition to properties and events, a component instance can also 
	be edited as a unit (known as component editing).  
	</para>
	
	<para>
	A component is persisted in a text based format that's very simple to read
	and can even be edited by hand if need be. The storage layout is basically a 
	listing of all the properties exposed by the component in a name/value format.
	The result of storing the component results in a hierarchical layout - each 
	child of the component is also stored. To actually store a component the 
	VFFOutputStream class is used. Please see the source documentation for this
	class for more information about it and the VFF component file format.
	</para>
	<section><title>Property Editing </title>
		<para>
		Property editing is the primary way of editing a component in a UI designer,
		like the one in the <ulink url="http://vcfbuilder.org">VCF Builder</ulink>.
		Each component class can expose various properties by using the VCF's RTTI 
		system. When selected, these properties are then displayed in a UI that allows
		the user to editing them individually. 
		</para>
		<para>
		Allowing the user to edit a property is the job of a property editor, which 
		is defined by the PropertyEditor interface. Property editors are associated
		with a particular type name (like and "int", "String", or even some class
		name) which is managed by the PropertyEditorManager class. The property editor
		can provide a custom UI for the user to use, and can also control how the 
		property is presented visually to the user. For example this is the default
		display for properties that are number types (such as an int or a double):
		
		<screenshot>
			<graphic fileref="gfx/default-pe.png"></graphic>
		</screenshot>
		The next example shows how the display is customized for a Font property, 
		showing the actual font settings to give the user a preview of what the
		property will look like:
		<screenshot>
			<graphic fileref="gfx/custom-pe.png"></graphic>
		</screenshot>
		</para>
		
		<para>
		A property editor can have attributes that indicate how it is to be used. These
		can indicate that the property should be displayed as a series of potential values,
		or that the property is itself an object, and that it has child properties that can 
		also be edited. The Font property is a good example. The Font itself is an object
		with properties, and we can see in the screen shot below that the UI shows this:
		<screenshot>
			<graphic fileref="gfx/pe-subprops.png"></graphic>
		</screenshot>		
		</para>
		
		<section><title>Creating a new property editor class</title>
			<para>
			When creating a custom property editor, the easiest way to do so is to derive a 
			new class from VCF::AbstractPropertyEditor. This provides some basic implementations
			for you, nad just in general makes it easier than starting from scratch implementing 
			the PropertyEditor interface.
			<programlisting>
			<![CDATA[
class MyPropertyEditor : public AbstractPropertyEditor {
public:
	MyPropertyEditor(){}

};			
			]]>
			</programlisting>
			Deriving from VCF::AbstractPropertyEditor simplifies what you need to implement for
			your property editor. This gives us a basic, bare bones implementation to work from. 
			It's also possible to derive from some other existing property editors, such as:
			<table frame="none" pgwide="1">			
				<tgroup cols="2" align="left" colsep="0" rowsep="0">
					<thead>
						<row>
							<entry>Type(s)</entry>
							<entry>Property editor class</entry>
						</row>							
					</thead>
					<tbody>
						<row>
							<entry>int, long, or short</entry>
							<entry>VCF::IntegerPropertyEditor</entry>
						</row>
						<row>
							<entry>double, float</entry>
							<entry>VCF::DoublePropertyEditor</entry>
						</row>
						
						<row>
							<entry>bool</entry>
							<entry>VCF::BoolPropertyEditor</entry>
						</row>
						
						<row>
							<entry>String</entry>
							<entry>VCF::StringPropertyEditor</entry>
						</row>
						
						<row>
							<entry>double, float</entry>
							<entry>VCF::IntegerPropertyEditor</entry>
						</row>
						
						<row>
							<entry>enum</entry>
							<entry>VCF::EnumPropertyEditor</entry>
						</row>
						
						<row>
							<entry>VCF::Color</entry>
							<entry>VCF::ColorPropertyEditor</entry>
						</row>
						
						<row>
							<entry>VCF::Font</entry>
							<entry>VCF::FontPropertyEditor</entry>
						</row>					
					</tbody>
				</tgroup>
			</table>
			</para>
			
			<section><title>Attributes</title>
			<para>
			Each property editor has a series of attributes that tell the "host"
			UI how the editor should be displayed or how it should be handled. For example,
			if the property editor has the PropertyEditor::paReadOnly attribute, this 
			indicates that the property is read-only, it cannot be modified by the 
			editor. If the editor has the PropertyEditor::paNeedsCustomPaint attribute,
			then this indicates that the editor can paint itself, and the host should call
			the editor's paintValue() method during the paint cycle. A complete list is diplayed
			in the table below:
			<table frame="none" pgwide="1">
				<tgroup cols="2" align="left" colsep="0" rowsep="0">
					<thead>
						<row>
							<entry>Attribute</entry>
							<entry>Meaning</entry>
						</row>							
					</thead>
					<tbody>
						<row>
							<entry>PropertyEditor::paHasValues</entry>
							<entry>	Indicates that the property editor can return a vector of 
							string values that represent possible values for the property. For 
							example, a color property editor might return a list of color names. 
							A Font editor might return a list of system fonts.</entry>
						</row>
						
						<row>
							<entry>PropertyEditor::paSortValues </entry>
							<entry>Indicates that the values returned by the editor need to be 
							sorted.	The sort process should call the PropertyEditor::sort() method 
							while iterating through the list.</entry>
						</row>
						
						<row>
							<entry>PropertyEditor::paHasSubProperties </entry>
							<entry>Indicates that the source object's property itself has sub 
							properties. Things like a font or color property may use this to 
							indicate separate elements that can be set.</entry>
						</row>
						
						<row>
							<entry>PropertyEditor::paAllowsMultiSelect </entry>
							<entry>Indicates whether or not the editor allows multiple selection. 
							If the editor does have this set, then it needs to implement the 
							PropertyEditor::setSources() method.</entry>
						</row>
						
						<row>
							<entry>PropertyEditor::paReadOnly </entry>
							<entry>Indicates that the editor is read only - the value cannot be 
							changed and is only for display.</entry>
						</row>
						
						<row>
							<entry>PropertyEditor::paNeedsCustomPaint </entry>
							<entry>Indicates that the editor can paint it's representation when 
							the editor is not active.</entry>
						</row>
						
						<row>
							<entry>PropertyEditor::paUsesModalDialogForEditing  </entry>
							<entry>This indicates that the implementor will display a modal dialog 
							when the PropertyEditor::edit() method is called.</entry>
						</row>
						
						<row>
							<entry>PropertyEditor::paValueNeedsDuplicating </entry>
							<entry>This indicates that the property value of the editor needs to 
							be cloned. This only makes sense if the property type is some sort of 
							Object instance. The object should be cloned by a call to the original 
							object's Object::clone() method.</entry>
						</row>
					</tbody>	
				</tgroup>
			</table>	
			</para>
			<para>
			You can change the attributes your editor supports by modifying the 
			AbstractPropertyEditor::attributes_ member variable. For example, to make the
			editor read-only:
			<programlisting>
			<![CDATA[
class MyPropertyEditor : public AbstractPropertyEditor {
public:
	MyPropertyEditor(){
		attributes_ = PropertyEditor::paReadOnly;
	}

};			
			]]>
			</programlisting>
			If you wanted to make the editor have values, for example, the values "One" and "Two":
			<programlisting>
			<![CDATA[
class MyPropertyEditor : public AbstractPropertyEditor {
public:
	MyPropertyEditor(){
		attributes_ = PropertyEditor::paHasValues;
	}
	
	virtual std::vector<String> getStringValues(){
		std::vector<String> result(2);
		result[0] = "One";
		result[1] = "Two";
		return result;
	}
};			
			]]>
			</programlisting>
			When the host displays your editor, it will use a combo box control, and populate it's
			list with two elements - "One" and "Two" - after calling the getStringValues() method
			of your editor instance.
			</para>
			</section>
			<section><title>Storing the property's value</title>
			<para>
			The value for a property is set or retreived by using a VariantData class. The 
			PropertyEditor::setValue() and PropertyEditor::getValue() are the methods
			that deal with this. Since we're deriving from AbstractPropertyEditor, a member 
			variable is provided for us, and the default implementation handles getting and 
			setting these values. 
			</para>
			<para>
			Most of the time the values will be basic types like an int, a bool, or a
			String. However, sometimes the value is an Object instance, which may need to
			be copied, as opposed to just copying the pointer value. This is indicated by the 
			property editor having the PropertyEditor::paValueNeedsDuplicating attribute. 
			The default implementation in the AbstractPropertyEditor class handles 
			copying the object if PropertyEditor::paValueNeedsDuplicating is set. 
			</para>
			<para>
			As a rule, if the value your proeprty editor wraps is an Object instance, then
			you'll probably need to have the PropertyEditor::paValueNeedsDuplicating attribute 
			set.
			</para>
			<para>
			In addition to setting the value of the property editor by way of a VariantData object,
			the editor also needs to accept data in the form of a string. This is what the 
			PropertyEditor::setValueAsText() method is for. Again the AbstractPropertyEditor
			implements this for us, by simply calling the VariantData's setFromString()
			method.
			</para>
			</section>
			<section><title>Retreiving the property's value</title>
			<para>
			When the host needs to get the data stored by the property editor, it calls either
			PropertyEditor::getValue() or PropertyEditor::getValueAsText(). The AbstractPropertyEditor			
			implements both of these for us, so in general we don't need to worry about them.
			</para>
			</section>
			<section><title>Sub Properties</title>
			<para>
			Some propert editor's have what are called "sub properties". In other words, the
			object that the property editor represents is itself made of properties, and 
			you can edit these properties as well. For example, if we were representing a 
			Font, the font itself contains properties, thus our property editor would have 
			"sub properties" and it would have the PropertyEditor::paHasSubProperties
			set. The host implementation will do the rest in terms of presenting a suitable 
			UI for the sub proeprties. In the case of the VCF Builder that's why we see the
			tree view presentation with the disclosure button to display the sub properties.
			</para>
			</section>
			
			<section><title>Multiple values and sorting</title>
			<para>
			As mentioned earlier, some property editors can display one or more default values
			in list. This is done by making sure the PropertyEditor::paHasValues attribute is
			set and then implementing the getStringValues() method to return a suitable vector
			of string values. For example, the Color property editor returns a list of 
			color names like so:
			<programlisting>
			<![CDATA[

std::vector<String> ColorPropertyEditor::getStringValues()
{
	int count = ColorNames::uniqueColorLast-ColorNames::uniqueColorFirst;
	std::vector<String> result(count);

	for ( int i=ColorNames::uniqueColorFirst;i<ColorNames::uniqueColorLast;i++ ) {
		result[i-ColorNames::uniqueColorFirst] = ColorNames::at( (ColorNames::ColorID)i );
	}

	return result;
}			
			]]>
			</programlisting>
			We determine the number of unique color names (count), set a vector of strings
			to be this size, and then loop through the color names, retreiving each one. The
			host will call this and fill in a suitable presentation for the user to select one
			of the values. In the VCF Builder this is accomplished by using an ComboBoxControl 
			and populating it's ListModel.
			<screenshot>
				<graphic fileref="gfx/pe-hasvalues.png"></graphic>
			</screenshot>			
			</para>
			<para>
			In addition to having a list of values, the property editor can also specify a specific 
			sort order for these values. By implementing the PropertyEditor::sort() method, you
			can control how the host will display your values. The PropertyEditor::sort() takes
			two string values, and returns a boolean value. An example of this can be seen in 
			the Color property editor, which simply implements this as a simple string compare:
			<programlisting>
			<![CDATA[
bool ColorPropertyEditor::sort( const String& strVal1, const String& strVal2 )
{
	return strVal1 > strVal2;
}			
			]]>
			</para>
			</section>
			<section><title>Painting the display of a property</title>
			<para>
			You can control the way a property editor display's a property by setting the 
			PropertyEditor::paNeedsCustomPaint attribute, and implementing the 
			PropertyEditor::paintValue() method. The host will call your paintValue()
			method and pass in a VariantData pointer for the property value, a GraphicsContext
			instance for the current GraphicsContext to paint on, a Rect instance that defines
			the drawable area you can paint in, and finally a DrawUIState that indicates the 
			current UI state.
			</para>
			</section>
			<para>			
			</para>
		</section>
	</section>
	
	<section><title>Component Editing </title>
		<para>
		</para>
	</section>
	
	<section><title>Saving and Loading Component State </title>
		<para>
		</para>
	</section>
	
	<section><title>Registering Components </title>
		<para>
		</para>
	</section>
	
	<section><title></title>
		<para>
		</para>
	</section>
</section>

<!--
CVS Log info
$Log$
Revision 1.2.12.7  2005/09/01 03:56:52  ddiego
doc updates and some minor mods to the property editor interface.

Revision 1.2.12.6  2005/08/30 21:05:04  ddiego
comp authoring updates.

Revision 1.2.12.2  2005/08/30 03:39:36  ddiego
more component authoring info.

Revision 1.2.12.1  2005/08/29 03:26:19  ddiego
adding compoent editing docs.

Revision 1.2  2003/12/18 05:15:52  ddiego
merge from devmain-0-6-2 branch into the stable branch

Revision 1.1.2.1  2003/09/24 19:41:18  ddiego
switched the sgml files over to xml file extensions
made a slight adjustment to the docbook makefile

Revision 1.2  2003/05/17 20:36:51  ddiego
this is the checkin for the 0.6.1 release - represents the merge over from
the devmain-0-6-0 branch plus a few minor bug fixes

Revision 1.1.2.1  2003/03/03 03:39:49  ddiego
initial check-in of docbook vcf documentation, plus neccesary stylsheets
and images


-->