<!--
Copyright (c) 2000-2003, Jim Crafton
All rights reserved.
Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions
are met:
	Redistributions of source code must retain the above copyright
	notice, this list of conditions and the following disclaimer.

	Redistributions in binary form must reproduce the above copyright
	notice, this list of conditions and the following disclaimer in 
	the documentation and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS
OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

NB: This software will not save the world.
CVS Log info
$Log$
Revision 1.1.2.3  2003/03/04 04:53:51  ddiego
filled some docs

Revision 1.1.2.2  2003/03/03 22:42:41  ddiego
stuff

Revision 1.1.2.1  2003/03/03 03:39:49  ddiego
initial check-in of docbook vcf documentation, plus neccesary stylsheets
and images

-->

<section><title>ApplicationKit</title>
	<para>
	</para>
	<section><title>Applications </title>
		<para>
		In the VCF an user inteface application can have a central class that derives 
		from the VCF::Application class. The application class handles the details of 
		starting thea application, initializing it, starting the event loop, and 
		terminating gracefully when the user exits the application, or an exception
		occurrs. 
		</para>
		<para>
		It is possible to use the VCF with out an application class, particularly if 
		you are integrating with another toolkit. In this case it is assumed that 
		an event loop is already running, and certain features that depend on an 
		Application instance may not work.
		</para>
		<para>
		An application either represents a program (or process) or a library in the
		form of a dynamic link library (DLL) or shared object (SO). If the application
		is part of a library then the specific instance must be dericed from 
		VCF::LibraryApplication. There can be more than one LibraryApplication instance
		loaded. 
		</para>
		<para>
		If the application represents a program, then there can only be one instance of
		it during the lifetime of the program. Creating more than the one instance is 
		incorrect and will break the application.
		</para>
		<para>
		To use the Application class, simply create an instance on the stack in your programs
		main() function, and then call the Application's static method, Application::appMain().
		<programlisting>
int main( int argc, char** argv ) 
{
	Application app;
	
	Application::appMain( argc, argv );
	return 0;
}
		</programlisting>
		</para>
		<para>
		This will start the program running, call the Application's initRunningApplication() method,
		and then start the event loop. The Application stores it's arguments in a std::vector of 
		Strings, in the member variable Application::m_cmdLine. You can retreive the current 
		running instance of the Application by calling Application::getRunningInstance().
		</para>
		<para>
		You can customize the initialization of your application by overriding the 
		Application's initialize() method.
		<programlisting>
class MyApplication : public Application {
public:
	virtual bool initRunningApplication() {		
		bool result = Application::initRunningApplication();
		
		//your customizations here
		
		return result;
	}
};
		</programlisting>
		<note>
			<para>
			Don't forget to call the base class's initRunningApplication() method, or you may see 
			incorrect or undefined behaviour.
			</para>
		</note>
		</para>
		<para>
		You can use your new class like so:
		<programlisting>
int main( int argc, char** argv ) 
{
	MyApplication app;
	
	Application::appMain( argc, argv );
	return 0;
}
		</programlisting>
		
		</para>
		<para>
		You can customize functionality for closing the Application as well by overriding the 
		terminateRunningApplication() method. 
		<programlisting>
class MyApplication : public Application {
public:
	//rest of declaration
	virtual void terminateRunningApplication() {
		//your customizations here
		
		Application::terminateRunningApplication();
	}
};
		</programlisting>
		</para>
	</section>

	<section><title>UI Toolkit </title>
		<para>
		</para>
	</section>
	
	<section><title>Event loops </title>
		<para>
		</para>
	</section>
	
	<section><title>Drag and Drop </title>
		<para>
		</para>
	</section>
	
	<section><title>Components </title>
		<para>
		</para>
	</section>
	
	<section><title>Controls and Containers </title>
		<para>
		</para>
	</section>
	
	<section><title>Layout </title>
		<para>
		</para>
	</section>
	
	<section><title>Frames, Dialogs, and Windows </title>
		<para>
		</para>
	</section>
	
	<section><title>Models </title>
		<para>
		</para>
	</section>
	
	<section><title>Items </title>
		<para>
		</para>
	</section>
	
	<section><title>Views </title>
		<para>
		</para>
	</section>
	
	<section><title>Undo/Redo and Commands </title>
		<para>
		</para>
	</section>
	
	<section><title>Control Activation </title>
		<para>
		</para>
	</section>
	
	<section><title>Accelerator Keys ("Hot Keys") </title>
		<para>
		</para>
	</section>		
	
	<section><title>Peer Classes</title>
		<para>
		</para>
	</section>
</section>
		
		