<!--
Copyright (c) 2000-2003, Jim Crafton
All rights reserved.
Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions
are met:
	Redistributions of source code must retain the above copyright
	notice, this list of conditions and the following disclaimer.

	Redistributions in binary form must reproduce the above copyright
	notice, this list of conditions and the following disclaimer in 
	the documentation and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS
OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

NB: This software will not save the world.
CVS Log info
$Log$
Revision 1.1.2.9  2003/03/13 05:06:51  ddiego
added some more documentation, and implemented the clone() method in all of the
core event classes for the FoundationKit, GraphicsKit, and ApplicationKit.

Revision 1.1.2.8  2003/03/13 02:34:40  ddiego
added some more docs and broke apart the various "books" so they can be all
put together or in separate books. Made to changes to Makefile

Revision 1.1.2.7  2003/03/10 03:58:34  ddiego
fixes ot better support online html, plus the addition of a little C++
program to stip stuff

Revision 1.1.2.6  2003/03/07 22:24:07  ddiego
added initial vcf builders docbook files

Revision 1.1.2.5  2003/03/07 04:33:02  ddiego
added more docs for appkit. made some mods to the vcf.xsl stylesheet
to turn on section numbering

Revision 1.1.2.4  2003/03/06 22:16:51  ddiego
jkl

Revision 1.1.2.3  2003/03/04 04:53:51  ddiego
filled some docs

Revision 1.1.2.2  2003/03/03 22:42:41  ddiego
stuff

Revision 1.1.2.1  2003/03/03 03:39:49  ddiego
initial check-in of docbook vcf documentation, plus neccesary stylsheets
and images

-->

<section><title>ApplicationKit</title>
	<para>
	</para>
	<section><title>Applications </title>
		<para>
		In the VCF an user inteface application can have a central class that derives 
		from the VCF::Application class. The application class handles the details of 
		starting thea application, initializing it, starting the event loop, and 
		terminating gracefully when the user exits the application, or an exception
		occurrs. 
		</para>
		<para>
		It is possible to use the VCF with out an application class, particularly if 
		you are integrating with another toolkit. In this case it is assumed that 
		an event loop is already running, and certain features that depend on an 
		Application instance may not work.
		</para>
		<para>
		An application either represents a program (or process) or a library in the
		form of a dynamic link library (DLL) or shared object (SO). If the application
		is part of a library then the specific instance must be dericed from 
		VCF::LibraryApplication. There can be more than one LibraryApplication instance
		loaded. 
		</para>
		<para>
		If the application represents a program, then there can only be one instance of
		it during the lifetime of the program. Creating more than the one instance is 
		incorrect and will break the application.
		</para>
		<para>
		To use the Application class, simply create an instance on the stack in your programs
		main() function, and then call the Application's static method, Application::appMain().
		<programlisting>
int main( int argc, char** argv ) 
{
	Application app;
	
	Application::appMain( argc, argv );
	return 0;
}
		</programlisting>
		</para>
		<para>
		This will start the program running, call the Application's initRunningApplication() method,
		and then start the event loop. The Application stores it's arguments in a std::vector of 
		Strings, in the member variable Application::m_cmdLine. You can retreive the current 
		running instance of the Application by calling Application::getRunningInstance().
		</para>
		<para>
		You can customize the initialization of your application by overriding the 
		Application's initialize() method.
		<programlisting>
class MyApplication : public Application {
public:
	virtual bool initRunningApplication() {		
		bool result = Application::initRunningApplication();
		
		//your customizations here
		
		return result;
	}
};
		</programlisting>
		<note>
			<para>
			Don't forget to call the base class's initRunningApplication() method, or you may see 
			incorrect or undefined behaviour.
			</para>
		</note>
		</para>
		<para>
		You can use your new class like so:
		<programlisting>
int main( int argc, char** argv ) 
{
	MyApplication app;
	
	Application::appMain( argc, argv );
	return 0;
}
		</programlisting>
		
		</para>
		<para>
		You can customize functionality for closing the Application as well by overriding the 
		terminateRunningApplication() method. 
		<programlisting>
class MyApplication : public Application {
public:
	//rest of declaration
	virtual void terminateRunningApplication() {
		//your customizations here
		
		Application::terminateRunningApplication();
	}
};
		</programlisting>
		</para>
	</section>

	<section><title>UI Toolkit </title>
		<section><title>Intro</title>
			<para>
			The UI Toolkit is used to create instances of various peer's needed by the VCF,
			as well as providing certain low level services, such as modal and non-modal event
			loops, and getting at UI metrics. Each system the VCF is ported to has a concrete
			implementation of the UIToolkit. The UIToolkit is a singleton, and there should 
			only be <emphasis>one</emphasis> instance for a given process running the VCF
			libraries.
			</para>
			<para>
			To work with the toolkit you retreive it's instance via a static function,
			<function>UIToolkit::getDefaultUIToolkit()</function>. If no toolkit is found 
			(which is an extremely bad thing!) a NoToolKitFoundException is thrown. A 
			quick example:
			<programlisting>
try {			
	UIToolkit* toolkit = UIToolkit::getDefaultUIToolkit();
}
catch ( NoToolKitFoundException &amp; e ) {
	//we are screwed!!!
	System::print( e.getMessage() );
}

			</programlisting>
			</para>
		</section>
		
		
		<section><title>UI Metrics</title>
			<para>
			UI Metrics are used to indicate a variety of user interface values, 
			such as the preferred font for controls are, or the preferred vertical 
			spacing between controls. These values are read only and may not be changed.
			</para>
			<para>
			The UI Metrics are intended to be a guide. It allows you properly control the spacing between controls, 
			something that is frequently guess work and done with hard coded values. By using the UI Metrics provided
			by the toolkit, you can ensure that the values you work with are standard and consistent for the platform you
			app is running on. It also makes sure that the values you use take into account the DPI resolution of the current
			screen settings, so that a change in these settings does not adversely affect your layout of your GUI.
			</para>			
			<para>
			An example of this is writing code that creates a label and an edit box, and wanting to ensure that the vertical
			spacing between the two is consistent and in line with the platform UI rules. This is extremely important when creating 
			a professional UI.
			</para>
			<para>
			Another feature of UI Metrics is the ability to get the right Font for various common controls. For example, the font used for
			displaying status versus the font used in a message dialog, is frequently different, and may depend on the users settings
			within the system. By using the UI Metrics you dont' have to resort to guess work as to what this is.
			</para>			
		</section>
		
		<section><title>Event Loops</title>			
		Please see the section on <link linkend="AppKit_EventLoops">Event loops</link> for a 
		more through discussion.
		</section>
		
		<section><title>Timers</title>
			<para>
			A timer in the VCF is an instance of the EventHandler class that is called repeatedly until the handler is removed. 
			The duration between calls is specified in milliseconds, and you can specify the duration in the call to register the 
			timer handler. Each time the handler is called, a TimerEvent instance is created, with it event type set to 
			TIMER_EVENT_PULSE. The event is then passed to the handler's invoke() method.
			</para>
			<para>
			A timer in the VCF is not run in a separate thread, instead it is in the thread of execution that started the event 
			loop. If you need a timer mechanism that is in a separate thread then you should use the Thread class for writing 
			one.
			</para>
			<para>
			To add a timer all you have to do is call the toolkit's <function>UIToolkit::registerTimerHandler()</function>. This
			method is not static, so you'll first need to get an instance of the toolkit. To call registerTimerHandler() you need 
			to pass in an instance of a VCF::Object (or some class derived from it), and a VCF::EventHandler instance. In 
			addition you specify the duration of the timer, or how long to wait till the next time to call the handler's invoke() 
			method. The Object you pass in represents the source that is used for all TimerEvents that get created.
			</para>
			<para>
			You can stop a timer by calling the toolkit's <function>UIToolkit::unregisterTimerHandler()</function> method and 
			passing in the same event handler instance that was passed to 
			<function>UIToolkit::registerTimerHandler()</function>.
			</para>
		</section>
		
		<section><title>Carets</title>		
			<para>
			A caret is a little rectangular (usually) graphic that flashs and shows the current position within a section of text. 
			Typically the caret is used in text controls.
			</para>
		</section>	
		
		
		<section><title>Posting Events</title>
			<para>
			Calling functions that fire events, or firing an event yourself via a Delegate is always synchronous behaviour, and 
			you must wait for any callbacks before proceeding. However you can also <emphasis>post</emphasis> an 
			event, which allows you to go on with your immediate processing and puts the event on the toolkits event 
			queue for later processing.
			</para>
			<para>
			To post an event you need to create a an event instance. With synchronous behaviour, you can create an event
			instance on the stack, for example:
			<programlisting>
			<![CDATA[
//get the control some how
Control* someControl = ...;

MouseEvent e; //event is created on the stack
//fill in the mouse event
//send the event to the control for handling
someControl->handleEvent( &e ); //we block here till all the event handling is done
			]]>
			</programlisting>
			However when you post an event, you <emphasis>must</emphasis> create the event on heap, since you will not
			have control over when it gets destroyed. If you already have an existing event the easiest thing to do is to 
			clone it, by calling the event's clone() method, and pass this cloned event instance to the post method. 

			
			 <note>
			 this is actually a virtual method first defined in VCF::Object.
			 </note>
			
			</para>
			<para>
			Once you have an event instance ready, you can post the event by either creating a new event handler
			instance or getting an existing one, and then call the toolkit's postEvent() method. You can 
			optionally tell the toolkit to <emphasis>not</emphasis> auotmatically delete the handler 
			for you by passing in a boolean value set to false (the default behaviour is to delete the handler
			you pass in). The event instance that is passed in is deleted automatically for you when the event
			is finished processing.
			</para>
		</section>
		
		<section><title>Default Buttons</title>		
			<para>
			A default button is a button whose click method will get called fired when the user hits the 
			return key. The button does not have to have the current focus for this to happen. Typically
			a default button has some visual indicator that easily distinguishes it from other buttons. 
				<note>
				On Win32 systems the default button usually has a 1 pixel black border around it's edges.
				On MacOSX the button is darker shade of blue and pulses.
				</note>
			</para>
			<para>
			You can set the default button programmatically by calling hte toolkit's setDefaultButton()
			method. You pass in any control that implements the VCF::Button interface. 
			</para>
			<para>
			To determine the current default button, call the toolkit's getDefaultButton() method, which 
			will return the current default button instance, or NULL if there is no default button.
			</para>
			
		</section>
		
		<section><title>Accelerators</title>	
			<para>
			An accelerator is a 
			</para>	
		</section>
		
		
		<section><title>Creating Peers</title>		
		<para>
		The toolkit peer creation methods should never have to be called for general VCF 
		usage. If you are writing a new component/control that requires a peer to manage
		part of it's work, then you may have to call the appropriate peer creation method.
		</para>
		</section>
		
		<section><title>Miscellaneous</title>		
		</section>				
		
		<para>
		</para>
	</section>
	
	<section id="AppKit_EventLoops"><title>Event loops </title>
		<para>		
		</para>
	</section>
	
	<section><title>Drag and Drop </title>
		<para>
		</para>
	</section>
	
	<section><title>Components </title>
		<para>
		</para>
	</section>
	
	<section><title>Controls and Containers </title>
		<para>
		</para>
	</section>
	
	<section><title>Layout </title>
		<para>
		</para>
	</section>
	
	<section><title>Frames, Dialogs, and Windows </title>
		<para>
		</para>
	</section>
	
	<section><title>Models </title>
		<para>
		</para>
	</section>
	
	<section><title>Items </title>
		<para>
		</para>
	</section>
	
	<section><title>Views </title>
		<para>
		</para>
	</section>
	
	<section><title>Undo/Redo and Commands </title>
		<para>
		</para>
	</section>
	
	<section><title>Control Activation </title>
		<para>
		</para>
	</section>
	
	<section><title>Accelerator Keys ("Hot Keys") </title>
		<para>
		</para>
	</section>		
	
	<section><title>Peer Classes</title>
		<para>
		</para>
	</section>
</section>
		
		